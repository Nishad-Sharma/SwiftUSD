#ifndef MX_CLOSURE_TYPE_MTL
#define MX_CLOSURE_TYPE_MTL

// These are defined based on the HwShaderGenerator::ClosureContextType enum
// if that changes - these need to be updated accordingly.

#define CLOSURE_TYPE_DEFAULT 0
#define CLOSURE_TYPE_REFLECTION 1
#define CLOSURE_TYPE_TRANSMISSION 2
#define CLOSURE_TYPE_INDIRECT 3
#define CLOSURE_TYPE_EMISSION 4

// BSDF closure type for material layering
// response: accumulated light response
// throughput: remaining energy for layered materials
struct BSDF {
    vec3 response;
    vec3 throughput;
};

// Helper function for BSDF initialization (Metal doesn't support aggregate initialization)
inline BSDF MakeBSDF(vec3 response, vec3 throughput) {
    BSDF bsdf;
    bsdf.response = response;
    bsdf.throughput = throughput;
    return bsdf;
}

// EDF (Emissive Distribution Function) is simply a color value
#define EDF vec3

// Surface shader closure type
struct surfaceshader {
    vec3 color;
    vec3 transparency;
};

inline surfaceshader MakeSurfaceShader(vec3 c, vec3 t) {
    surfaceshader s;
    s.color = c;
    s.transparency = t;
    return s;
}

// Volume shader closure type
struct volumeshader {
    vec3 color;
    vec3 transparency;
};

inline volumeshader MakeVolumeShader(vec3 c, vec3 t) {
    volumeshader v;
    v.color = c;
    v.transparency = t;
    return v;
}

// Note: displacementshader struct is already defined in MslSyntax.cpp
// as a built-in type: struct displacementshader { float3 offset; float scale; };

inline displacementshader MakeDisplacementShader(vec3 o, float s) {
    displacementshader d;
    d.offset = o;
    d.scale = s;
    return d;
}

struct ClosureData {
    int closureType;
    vec3 L;
    vec3 V;
    vec3 N;
    vec3 P;
    float occlusion;
};

#endif // MX_CLOSURE_TYPE_MTL
