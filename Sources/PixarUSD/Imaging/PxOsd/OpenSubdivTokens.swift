/* ----------------------------------------------------------------
 * :: :  M  E  T  A  V  E  R  S  E  :                            ::
 * ----------------------------------------------------------------
 * Licensed under the terms set forth in the LICENSE.txt file, this
 * file is available at https://openusd.org/license.
 *
 *                                        Copyright (C) 2016 Pixar.
 *         Copyright (C) 2024 Wabi Foundation. All Rights Reserved.
 * ----------------------------------------------------------------
 *  . x x x . o o o . x x x . : : : .    o  x  o    . : : : .
 * ---------------------------------------------------------------- */

@preconcurrency import PxOsd

public extension PxOsd
{
  /// Cached static token type for efficient token access.
  /// Uses the C++ PxOsdOpenSubdivTokens_StaticTokenType generated by TF_DECLARE_PUBLIC_TOKENS.
  private struct StaticData: @unchecked Sendable
  {
    static let shared = StaticData()
    private init() {}
    let tokens = Pixar.PxOsdOpenSubdivTokens_StaticTokenType()
  }

  /**
   * # PxOsd.Tokens
   *
   * ## Overview
   *
   * Public, client facing api to access
   * the static PxOsd OpenSubdiv tokens.
   *
   * These tokens are used for subdivision schemes,
   * boundary interpolation rules, crease methods,
   * and other OpenSubdiv-related settings.
   */
  enum Tokens: CaseIterable
  {
    /// Apply subdivision to all faces
    case all
    /// Apply no subdivision
    case none
    /// Interpolate corners only
    case cornersOnly
    /// Interpolate corners plus one ring
    case cornersPlus1
    /// Interpolate corners plus two rings
    case cornersPlus2
    /// Boundary interpolation
    case boundaries
    /// Bilinear subdivision scheme (simple linear interpolation)
    case bilinear
    /// Catmull-Clark subdivision scheme (smooth curves/surfaces)
    case catmullClark
    /// Loop subdivision scheme (for triangle meshes)
    case loop
    /// Edge-only crease method
    case edgeOnly
    /// Edge and corner crease method
    case edgeAndCorner
    /// Uniform subdivision
    case uniform
    /// Chaikin subdivision
    case chaikin
    /// Left-handed winding orientation
    case leftHanded
    /// Right-handed winding orientation
    case rightHanded
    /// Smooth subdivision
    case smooth

    public func getToken() -> Tf.Token
    {
      switch self
      {
        case .all: StaticData.shared.tokens.all
        case .none: StaticData.shared.tokens.none
        case .cornersOnly: StaticData.shared.tokens.cornersOnly
        case .cornersPlus1: StaticData.shared.tokens.cornersPlus1
        case .cornersPlus2: StaticData.shared.tokens.cornersPlus2
        case .boundaries: StaticData.shared.tokens.boundaries
        case .bilinear: StaticData.shared.tokens.bilinear
        case .catmullClark: StaticData.shared.tokens.catmullClark
        case .loop: StaticData.shared.tokens.loop
        case .edgeOnly: StaticData.shared.tokens.edgeOnly
        case .edgeAndCorner: StaticData.shared.tokens.edgeAndCorner
        case .uniform: StaticData.shared.tokens.uniform
        case .chaikin: StaticData.shared.tokens.chaikin
        case .leftHanded: StaticData.shared.tokens.leftHanded
        case .rightHanded: StaticData.shared.tokens.rightHanded
        case .smooth: StaticData.shared.tokens.smooth
      }
    }
  }

  /**
   * # PxOsd.SubdivisionScheme
   *
   * Subdivision scheme enumeration for mesh topology.
   * These define how the mesh surface is subdivided.
   */
  enum SubdivisionScheme
  {
    /// Catmull-Clark subdivision - creates smooth surfaces from polygonal meshes
    case catmullClark
    /// Loop subdivision - specialized for triangle meshes
    case loop
    /// Bilinear subdivision - simple linear interpolation
    case bilinear
    /// No subdivision - keep original geometry
    case none

    public var token: Tf.Token
    {
      switch self
      {
        case .catmullClark: Tokens.catmullClark.getToken()
        case .loop: Tokens.loop.getToken()
        case .bilinear: Tokens.bilinear.getToken()
        case .none: Tokens.none.getToken()
      }
    }

    public init?(token: Tf.Token)
    {
      switch token.string
      {
        case "catmullClark": self = .catmullClark
        case "loop": self = .loop
        case "bilinear": self = .bilinear
        case "none": self = .none
        default: return nil
      }
    }
  }

  /**
   * # PxOsd.Orientation
   *
   * Winding order orientation for mesh faces.
   */
  enum Orientation
  {
    /// Left-handed winding order
    case leftHanded
    /// Right-handed winding order (OpenGL default)
    case rightHanded

    public var token: Tf.Token
    {
      switch self
      {
        case .leftHanded: Tokens.leftHanded.getToken()
        case .rightHanded: Tokens.rightHanded.getToken()
      }
    }

    public init?(token: Tf.Token)
    {
      switch token.string
      {
        case "leftHanded": self = .leftHanded
        case "rightHanded": self = .rightHanded
        default: return nil
      }
    }
  }

  /**
   * # PxOsd.BoundaryInterpolation
   *
   * Vertex boundary interpolation rules for subdivision surfaces.
   */
  enum BoundaryInterpolation
  {
    /// No boundary interpolation
    case none
    /// Interpolate corners only
    case cornersOnly
    /// Interpolate corners plus one neighboring vertex
    case cornersPlus1
    /// Interpolate corners plus two neighboring vertices
    case cornersPlus2
    /// Full boundary interpolation
    case all

    public var token: Tf.Token
    {
      switch self
      {
        case .none: Tokens.none.getToken()
        case .cornersOnly: Tokens.cornersOnly.getToken()
        case .cornersPlus1: Tokens.cornersPlus1.getToken()
        case .cornersPlus2: Tokens.cornersPlus2.getToken()
        case .all: Tokens.all.getToken()
      }
    }

    public init?(token: Tf.Token)
    {
      switch token.string
      {
        case "none": self = .none
        case "cornersOnly": self = .cornersOnly
        case "cornersPlus1": self = .cornersPlus1
        case "cornersPlus2": self = .cornersPlus2
        case "all": self = .all
        default: return nil
      }
    }
  }

  /**
   * # PxOsd.CreaseMethod
   *
   * Crease interpolation methods for semi-sharp edges.
   */
  enum CreaseMethod
  {
    /// Uniform creasing across edge
    case uniform
    /// Chaikin subdivision for creases
    case chaikin

    public var token: Tf.Token
    {
      switch self
      {
        case .uniform: Tokens.uniform.getToken()
        case .chaikin: Tokens.chaikin.getToken()
      }
    }

    public init?(token: Tf.Token)
    {
      switch token.string
      {
        case "uniform": self = .uniform
        case "chaikin": self = .chaikin
        default: return nil
      }
    }
  }
}
